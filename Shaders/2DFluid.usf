#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ShaderPrint.ush"
#include "Fluid/poissonFilterConvergene.ush"
#include "FluidCommon.ush"

#define G 9.8
#define OUTPUTTEXTURE SimGridUAV
#define Nc 64
int FluidShaderType;
float3 WorldVelocity;
float3 WorldPosition;
int bIsXDirector;
RWTexture2D<float> PressureGridUAV;

Texture2D<float4> PoissonFilterSRV;
Texture2D<float4> PoissonFilter1SRV;

RWTexture2D<float4> PoissonFilter1UAV;
RWTexture2D<float4> PoissonFilterUAV;
[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void PoissonFilterXCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{

	float4 PoissonFilterValue = 0.0;
	float4 PoissonFilterValue1 = 0.0;
	float4 sum0 = 0.0;
	float4 sum1 = 0.0;

	int MaxCellX,MaxCellY;
	PressureGridUAV.GetDimensions(MaxCellX,MaxCellY);
	float2 Resolve = float2(MaxCellX,MaxCellY);

	for (int i = -Nc; i <= Nc; i++)
	{
		float2 Pos =DispatchThreadId + float2(i, 0);//Wrap(DispatchThreadId + float2(i, 0), Resolve);

		float Density = PressureGridUAV[Pos] ;//+ SimGridSRV.Load(int3(Pos,0)).z*0.99;

		int id = (i + Nc);
		//loop over ranks
		for(int j = 0; j < 4; j++)
		{//
			//
			sum0[j] += Density * R14_Filters_Hor[id][j];//U[id + 2 * j * N];
			sum1[j] += Density * R58_Filters_Hor[id][j];//U[id + (2 * j + 1) * N];
		}
	}

	//loop over pairs of ranks
	for(int j = 0; j < 4; j++)
	{
		PoissonFilterValue[j] = sum0[j];
		PoissonFilterValue1[j] = sum1[j];
	}
	PoissonFilterUAV[DispatchThreadId] = PoissonFilterValue;
	PoissonFilter1UAV[DispatchThreadId] = PoissonFilterValue1;
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void PoissonFilterYCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{

	float Pressure = 0.0;
	int MaxCellX,MaxCellY;
	PressureGridUAV.GetDimensions(MaxCellX,MaxCellY);
	float2 Resolve = float2(MaxCellX,MaxCellY);
	for (int i = -Nc; i <= Nc; i++)
	{
		float2 Pos = DispatchThreadId + float2(0, i);
		/*float2 Pos = (ReadPos + Resolve) % Resolve;//Wrap(DispatchThreadId + float2(0, i), Resolve);
		Pos.x = (Pos.x + Resolve.x) % Resolve.x;
		Pos.y = (Pos.y + Resolve.y) % Resolve.y;*/
		int id = (i + Nc);
		float4 data = PoissonFilterSRV[Pos];
		float4 data1 = PoissonFilter1SRV[Pos];
		//loop over pairs of ranks
		for(int j = 0; j < 4; j++)
		{//
			//
			Pressure += data[j] * R14_Filters_ver[id][j];//V[i + Nc + 2 * j * N];
			Pressure += data1[j] * R58_Filters_ver[id][j];//V[i + Nc + (2*j + 1) * N];
		}
	}

	//return the final poisson solution
	PressureGridUAV[DispatchThreadId] = Pressure;
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void ComputeDivergenceCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	float Divergence = GetDivergence(SimGridSRV, int2(DispatchThreadId), dx);
	PressureGridUAV[DispatchThreadId] = Divergence / dt;
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void AdvectionCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	int MaxCellX,MaxCellY;
	SimGridUAV.GetDimensions(MaxCellX,MaxCellY);

	float2 inverseResolution = 1.0 / float2(MaxCellX,MaxCellY);
	float2 UV = (DispatchThreadId + 0.5) * inverseResolution;

	float2 v1 = SimGridSRV.SampleLevel(SimSampler, UV,0).xy;
	/*float2 v2 = SimGridSRV.SampleLevel(SimSampler, UV - 0.5 * v1 * dt * inverseResolution,0).xy;
	float2 v3 = SimGridSRV.SampleLevel(SimSampler, UV - 0.5 * v2 * dt * inverseResolution,0).xy;
	float2 v4 = SimGridSRV.SampleLevel(SimSampler, UV - v3 * dt * inverseResolution,0).xy;*/
	float2 OldVelocity = v1;//(1.0 * v1 + 2.0 * v2 + 2.0 * v3 + 1.0 * v4) / 6.0;
    
	float2 SamplePos = UV - OldVelocity * dt * inverseResolution;
	float4 SampleData  = SimGridSRV.SampleLevel(SimSampler, SamplePos,0);

	float2 Velocity = SampleData.xy;

	float noiseScale = .05 * NoiseFrequency;

	float noiseX = simplex3d(float3(DispatchThreadId.xy, Time * 0.1) * noiseScale);
	//NoiseTexture.SampleLevel(WarpSampler, (DispatchThreadId.xy + float2(-Time, 0.2) * 0.2) / GridSize.xy * noiseScale, 0).x * 2 - 1 ;
	float noiseY = simplex3d(float3(DispatchThreadId.xy, Time * 0.05) * noiseScale);
	//(NoiseTexture.SampleLevel(WarpSampler, (DispatchThreadId.xy +  float2(0, -Time) * 0.1) / GridSize.xy * noiseScale, 0).y * 2 - 1) ;

	float2 CenterPoint =  float2(250,100)+float2(sin(Time*0.025),0)*100 ;
	float2 Dis = float2(DispatchThreadId) - CenterPoint;
	float Density = SampleData.w;


	// Add force.

	// Circle barrier.
	float2 BarrierPosition = float2(0.5, 0.5);
	float2 ToBarrier = BarrierPosition - UV;
	ToBarrier.x *= inverseResolution.y / inverseResolution.x;
	float BarrierRadiusSq = 0.02;

	Density = clamp(Density / (dt * DensityDissipate + 1) - dt * 0.1 * DensityDissipate, 0, 1);
	Velocity.x = clamp(Velocity.x / (dt * VelocityDissipate + 1) - dt * 0.1 * VelocityDissipate, -1000, 1000);
	Velocity.y = clamp(Velocity.y / (dt * VelocityDissipate + 1) - dt * 0.1 * VelocityDissipate, -1000, 1000);


	if (length(Dis) < 50)
	{
		Density += 0.1 + noiseX;//RandFast(DispatchThreadId*0.2,Time);
		Velocity = float2(noiseX * -3, noiseY * 1)*12;
	}
	Velocity += (GravityScale * float2(0,G)  + float2(noiseX,noiseY) * NoiseIntensity)* Density;
	float2 GradPressure = GetGradient(PressureGridUAV, int2(DispatchThreadId), dx);
	float4 OutputData = float4(Velocity, GradPressure.x, Density);

	if(dot(ToBarrier, ToBarrier) < BarrierRadiusSq)
	{

		//OutputData.xy = float2(ToBarrier.x,ToBarrier.y)*-100;//float4(ToBarrier.x,ToBarrier.y, 999.0, 0.0);
	}


    SimGridUAV[DispatchThreadId] = OutputData;

}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void PreVelocityCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	int MaxCellX,MaxCellY;
	PressureGridUAV.GetDimensions(MaxCellX,MaxCellY);
	float2 UV = (DispatchThreadId + 0.5) / float2(MaxCellX,MaxCellY);
	float2 GradPressure = GetGradient(PressureGridUAV, int2(DispatchThreadId), dx);
	float4 SimValue = SimGridSRV.SampleLevel(SimSampler, UV,0);
	float2 Velocity = SimValue.xy - GradPressure*dt*0.0001;

	int2 UVs[4] = {
		Wrap(DispatchThreadId  + int2(0, 1),float2(MaxCellX,MaxCellY)),
		Wrap(DispatchThreadId  + int2(0, -1),float2(MaxCellX,MaxCellY)),
		Wrap(DispatchThreadId  + int2(1, 0),float2(MaxCellX,MaxCellY)),
		Wrap(DispatchThreadId  + int2(-1, 0),float2(MaxCellX,MaxCellY)),
	};
	float EstimatedDensity1 = PressureGridUAV[UVs[0]];
	float EstimatedDensity2 = PressureGridUAV[UVs[1]];
	float EstimatedDensity3 = PressureGridUAV[UVs[2]];
	float EstimatedDensity4 = PressureGridUAV[UVs[3]];
	float EstimatedDensity = EstimatedDensity1 + EstimatedDensity2 + EstimatedDensity3 + EstimatedDensity4 - 4 * PressureGridUAV[DispatchThreadId];
	SimGridUAV[DispatchThreadId] = float4(Velocity,GradPressure.x,SimValue.w);

}

Texture2D<float> LastPressureSRV;
SamplerState ClampSampler;

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void JacobiIteratePressure(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	int MaxCellX,MaxCellY;
	SimGridUAV.GetDimensions(MaxCellX,MaxCellY);
	float2 inverseResolution = 1.0 / float2(MaxCellX,MaxCellY);
	float2 IDOffset = DispatchThreadId + 0.5;
	float2 UV = IDOffset * inverseResolution;
	float4 SimValue = SimGridSRV.SampleLevel(SimSampler,UV,1);//SimGridUAV.Load(int3(DispatchThreadId, 0));
	float2 Velocity = SimValue.xy;
	//float Density;
	int FluidCellCount = 4;
	int2 UVs[4] = {
		(IDOffset + int2(0, 1)) * inverseResolution,
		(IDOffset + int2(0, -1))* inverseResolution,
		(IDOffset + int2(-1, 0))* inverseResolution,
		(IDOffset + int2(1, 0)) * inverseResolution
	};

	float BoundaryAdd = 0.0;
	float4 UpVelocity = SimGridSRV.SampleLevel(SimSampler,UVs[0],1);
	float4 DownVelocity = SimGridSRV.SampleLevel(SimSampler,UVs[1],1);
	float4 LeftVelocity = SimGridSRV.SampleLevel(SimSampler,UVs[2],1);
	float4 RightUpVelocity = SimGridSRV.SampleLevel(SimSampler,UVs[3],1);


	float Divergence = (RightUpVelocity.x - LeftVelocity.x + (UpVelocity.y - DownVelocity.y)) / (2 * dx); //GetDivergence(SimGridUAV,DispatchThreadId,dx);//

	float Density = 1; //SimValue.z;

	float P_up = LastPressureSRV.SampleLevel(SimSampler,UVs[0],1);
	float P_down = LastPressureSRV.SampleLevel(SimSampler,UVs[1],1);
	float P_left = LastPressureSRV.SampleLevel(SimSampler,UVs[2],1);
	float P_right = LastPressureSRV.SampleLevel(SimSampler,UVs[3],1);
	if (floor(UpVelocity.a) == 1)
	{
		FluidCellCount--;
		BoundaryAdd += Density * dx * (Velocity.y - UpVelocity.y) / dt;
		P_up = 0;
	}
	if (floor(DownVelocity.a) == 1)
	{
		FluidCellCount--;
		BoundaryAdd -= Density * dx * (Velocity.y - UpVelocity.y) / dt;
		P_down = 0;
	}
	if (floor(LeftVelocity.a) == 1)
	{
		FluidCellCount--;
		BoundaryAdd -= Density * dx * (Velocity.x - LeftVelocity.x) / dt;
		P_left = 0;
	}
	if (floor(RightUpVelocity.a) == 1)
	{
		FluidCellCount--;
		BoundaryAdd += Density * dx * (Velocity.x - RightUpVelocity.x) / dt;
		P_right = 0;
	}

	float P_center = PressureGridUAV.Load(int3(DispatchThreadId, 0));
	int RowParity = (DispatchThreadId.y + IterationIndex) % 2;
	int CellParity = (DispatchThreadId.x + RowParity) % 2;
	float Weight = CellParity * 1.93;
	float JacobiPressure = (P_right + P_left + P_up + P_down - Density * dx * dx * Divergence / dt + BoundaryAdd) / FluidCellCount;

	PressureGridUAV[DispatchThreadId] = (1.f - Weight) * P_center + Weight * JacobiPressure; //lerp(P_center,JacobiPressure ,Weight);
}
