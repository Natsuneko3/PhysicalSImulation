#include  "/Engine/Public/Platform.ush"
RWTexture2D<int> OutTestShader;
int Time;
//[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 8)]
/*void MainCS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
	float Cell = 0.0;
	float2 CenterPoint = float2(sin(Time*0.01),cos(Time*0.01))*10 + float2(250,150);
	float Point = distance(float3(DispatchThreadID.x,DispatchThreadID.y,DispatchThreadID.z),float3(255,255,255));//length(float3(DispatchThreadID) - float3(CenterPoint.x,CenterPoint.y,255));
Point = length(float3(DispatchThreadID.x,DispatchThreadID.y,DispatchThreadID.z) - float3(255.0,255.0,255.0)) - 200;
	OutTestShader[DispatchThreadID] =  saturate(Point);
}*/

void MainPS(out float4 OutWorldNormal : SV_Target0)
{
	OutWorldNormal = float4(1,0,0,0);
}

float trace()
{
	float4 ret = {0, 0, 0, 0};

	float WorldDepth = SceneDepth / dot(RayDir, CameraDirectionVector);

	float3 OriginalRayDir = RayDir;

	//
	//  Ray aabbox intersection
	//

	float3 dirfrac = 1.0f / RayDir;

	float t = 0;


	float3 MinBounds = -1. * WorldGridExtents * .5;
	float3 MaxBounds = WorldGridExtents * .5;
	float t1 = (MinBounds.x - RayStart.x) * dirfrac.x;
	float t2 = (MaxBounds.x - RayStart.x) * dirfrac.x;
	float t3 = (MinBounds.y - RayStart.y) * dirfrac.y;
	float t4 = (MaxBounds.y - RayStart.y) * dirfrac.y;
	float t5 = (MinBounds.z - RayStart.z) * dirfrac.z;
	float t6 = (MaxBounds.z - RayStart.z) * dirfrac.z;

	float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
	float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));

	// if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us
	if (tmax < 0)
	{
		t = tmax;
		return ret;
	}

	// if tmin > tmax, ray doesn't intersect AABB
	if (tmin > tmax)
	{
		t = tmax;
		return ret;
	}

	t = max(0, tmin);

	float3 CurrLocalPos = RayStart + RayDir * t;

	float SignedDistance = -10000;
	float3 FinalPos = float3(0, 0, 0);
	float4 RetVal = float4(0, 0, 0, 0);
	Whitewater = 0;
	for (int i = 0; i < NumSteps; ++i)
	{
		float3 Position = CurrLocalPos / WorldGridExtents + .5;
		float4 VolumeSample = VolumeTexture.SampleLevel(VolumeTextureSampler, Position, 0);
		SignedDistance = VolumeSample.r;
		if (abs(SignedDistance) > Tolerance && Position.x >= 0 && Position.x <= 1 && Position.y >= 0 && Position.y <= 1 && Position.z >= 0 && Position.z <= 1)
		{
			FinalPos = Position;
			RetVal = 1; //float4(normalize(VolumeSample.gba), 1);
			Whitewater = VolumeSample.g;
			Depth = t * dot(OriginalRayDir, CameraDirectionVector);
			break;
		}

		t += SignedDistance;
		CurrLocalPos = RayStart + RayDir * t;
	}


	if (t > WorldDepth)
	{
		RetVal.a = 0;
	}

	/*
	if (RetVal.a != 0 && ComputeNormals > 1 - 1e-5)
	{
		uint sx, sy, sz, l;
		VolumeTexture.GetDimensions(0, sx, sy, sz, l);
		float3 UnitDx = 1. / float3(sx, sy, sz);

		float S_right = VolumeTexture.SampleLevel(VolumeTextureSampler, FinalPos + float3(1, 0, 0) * UnitDx, 0).r;
		float S_left = VolumeTexture.SampleLevel(VolumeTextureSampler, FinalPos -
		                                         float3(1, 0, 0) * UnitDx, 0).r;
		float S_up = VolumeTexture.SampleLevel(VolumeTextureSampler, FinalPos +
		                                       float3(0, 1, 0) * UnitDx, 0).r;
		float S_down = VolumeTexture.SampleLevel(VolumeTextureSampler, FinalPos - float3(0, 1, 0) * UnitDx, 0).r;
		float S_front = VolumeTexture.SampleLevel(VolumeTextureSampler, FinalPos + float3(0, 0, 1) * UnitDx, 0).r;
		float S_back = VolumeTexture.SampleLevel(VolumeTextureSampler, FinalPos - float3(0, 0, 1) * UnitDx, 0).r;

		RetVal.rgb = normalize(float3(S_right + S_left, S_up - S_down, S_front - S_back));
	}#1#*/

	return RetVal;
}
