
//#include "/Engine/Private/ShaderPrint.ush"

#include "ParticleCommon.ush"

// Temporary buffer where we compute the number of elements to write before each input element.
groupshared uint GroupWriteOffsets[2*THREADGROUP_SIZEX];
// The offset where this thread group will start writing its output.
groupshared uint GroupWriteStart;

int ShaderType;
RWTexture3D<float> RasterizeTexture;
float GravityScale;
float LifeTime;
void FilterDeadParticle(uint DispatchThreadId , uint2 GroupThreadId , uint2 GroupID)
{
	int Array[64] = {0,1,2,-1,4,-1,-1,7,-1,9,10,-1,12,13,14,15,16,-1,18,-1,-1,21,22,23,24,25,26,27,-1,-1,30,-1,32,33,34,35,36,37,-1,39,40,41,42,43,44,45,-1,47,-1,49,-1,51,52,53,54,55,56,-1,58,59,-1,-1
		,62,63};

	ParticleIDBuffer[DispatchThreadId] = Array[DispatchThreadId];
	GroupMemoryBarrierWithGroupSync();

	uint InputStart = GroupID.x * THREADGROUP_SIZEX;
	uint Thread = GroupThreadId.x;
	uint ParticleID = InputStart + Thread;

	int OutBuffer = 0, InBuffer = 1;

	// Evaluate predicate for each input slot, then shift down by one position because we need an exclusive sum.
	if(Thread > 0)
	{
		uint IsFree = (ParticleIDBuffer[DispatchThreadId] == -1) ? 1 : 0;
		GroupWriteOffsets[Thread] = IsFree;
	}

	GroupMemoryBarrierWithGroupSync();

	// Compute prefix sum.
	[unroll]
	for(uint Offset = 1; Offset < THREADGROUP_SIZEX; Offset = Offset << 1)
	{
		// Swap the input and output buffers.
		OutBuffer = 1 - OutBuffer;
		InBuffer = 1 - InBuffer;
		if(Thread >= Offset)
		{
			GroupWriteOffsets[OutBuffer*THREADGROUP_SIZEX + Thread] = GroupWriteOffsets[InBuffer*THREADGROUP_SIZEX + Thread - Offset] + GroupWriteOffsets[InBuffer*THREADGROUP_SIZEX + Thread];
		}
		else
		{
			GroupWriteOffsets[OutBuffer*THREADGROUP_SIZEX + Thread] = GroupWriteOffsets[InBuffer*THREADGROUP_SIZEX + Thread];
		}
		GroupMemoryBarrierWithGroupSync();
	}

	if(Thread == 0)
	{
		// Add the value of the last predicate to get the total number of IDs that this group will write.
		uint LastIsFree = (ParticleIDBuffer[InputStart + THREADGROUP_SIZEX - 1] == -1) ? 1 : 0;
		uint NumGroupFreeIDs = GroupWriteOffsets[(OutBuffer + 1)*THREADGROUP_SIZEX - 1] + LastIsFree;
		// Add to the global write offset. The previous offset is where we start writing in the output buffer.
		InterlockedAdd(ParticleIDBuffer[0], NumGroupFreeIDs, GroupWriteStart);
	}
	GroupMemoryBarrierWithGroupSync();

	if(ParticleIDBuffer[DispatchThreadId] == -1)
	{
		// This is a free ID, output it.
		uint WriteOffset = GroupWriteStart + GroupWriteOffsets[OutBuffer*THREADGROUP_SIZEX + Thread];
		// TODO: consider buffering the results before writing to the output UAV.
		ParticleIDBuffer[WriteOffset] = ParticleID;
	}
}
void ParticleToCell(uint DispatchThreadId )
{
	/*ParticleContext Particle = GetParticle(DispatchThreadId);

	// if(Particle.Age == 0.0)
	// {
	// 	Particle = SpawnParticle(DispatchThreadId);
	// }
	OutPutParticle(DispatchThreadId,Particle);*/
}
void CellToParticle(uint DispatchThreadId )
{
	int active = 1;
	ParticleContext Particle = GetParticle(DispatchThreadId);
	GroupMemoryBarrierWithGroupSync();
	Particle.Velocity += float3(0,0,-9.8);
	Particle.Position += Particle.Velocity * dt;
	Particle.Age += dt;
	if(Particle.Age > LifeTime)
	{
		active = 0;
		int DeadNum = 0;
		InterlockedAdd(ParticleIDBuffer[0],1,DeadNum);
	}
	ParticleIDBuffer[DispatchThreadId + 1] = active;
	OutPutParticle(DispatchThreadId,Particle);
}
void Rasterize(uint DispatchThreadId)
{
	ParticleContext Particle = GetParticle(DispatchThreadId);
	float3 GridPosition = Particle.Position / (GridSize * dx);
	GridPosition = saturate(GridPosition) * GridSize;
	int a = 1;
	int original_value = 0;
	//RasterizeTexture[int3(GridPosition)] = 1;
	int Radius = 20;
	for(int x = -Radius; x < Radius;x++)
	{
		for(int y = -Radius; y < Radius;y++)
		{
			for(int z = -Radius; z < Radius;z++)
			{
				int3 Position = int3(GridPosition + int3(x,y,z));
				//InterlockedMax(RasterizeTexture[uint3(0,0,0)],1,original_value);//
				RasterizeTexture[uint3(Position)] = 1;
			}
		}
	}
	//RasterizeTexture[uint3(0,0,0)] = 1;
	//InterlockedMax(RasterizeTexture[int3(GridPosition)],asfloat(a));

}
[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(uint DispatchThreadId : SV_DispatchThreadID, uint2 GroupThreadId : SV_GroupThreadID, uint2 GroupID:SV_GroupID)
{
	switch (ShaderType)
	{
	case P2G:
		ParticleToCell(DispatchThreadId);
		break;
	case  G2P:
		CellToParticle(DispatchThreadId);
		break;
	case RASTERIZE:
		Rasterize(DispatchThreadId);
		break;

	}

}
